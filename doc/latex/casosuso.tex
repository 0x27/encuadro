\chapter{Casos de Uso}

\section{Introducción}
En este capítulo se describen los distintos casos de uso que se implementaron con el fin de aplicar los algoritmos desarrollados en los capítulos anteriores. Se buscó generar distintos casos de uso que funcionaran como muestra de las funcionalidades que son posibles de realizar mediante la resolución de los algoritmos mencionados.
\section{Caso de Uso 01}
\subsection{Comentarios sobre el caso de uso}
\subsection{Detalles constructivos}
\section{Caso de Uso 02}
\subsection{Comentarios sobre el caso de uso}
Este caso de uso básicamente busca desplegar un video en una superfice dada del mundo real. Esto puede ser de gran interés como complemento de contenido para un cuadro o cualquier obra si se piensa en aplicarlo para museos. Es posible por ejemplo, generar un video que sea reproducido dentro de los marcos del propio cuadro, en un extremo o en una superficie cualquiera que resulte interesante desde el punto de vista artístico. A continuación se explican brevemente algunos detalles para lograr la implementación de este caso de uso.
\subsection{Detalles constructivos}
Para lograr lo propuesto para este caso de uso se implementó un proyecto que proyecta el video en uno de los cuadrados del marcador. De esta manera, de toda la lógica de estimación de pose, solamente se hace uso de la detección y filtrado. En particular no se hace uso de los resultados del posit. Teniendo entonces detectados los cuatro puntos en los que se quiere reproducir el video parecería que el problema está resuelto. Sin embargo, xcode no permite posicionar en forma directa una vista de video en cualquier conjunto de cuatro puntos. \\
Si simplemente se quiere reproducir un video, y no se quiere procesar el contenido, lo más cómodo para hacerlo es utilizar la clase \textit{MPMoviePlayerController} que hereda de \textit{NSObject}. Una alternativa similar es haciendo uso de la clase \textit{MPMoviePlayerViewController} que hereda de \textit{UIViewController} y tiene como única propiedad una del tipo \textit{MPMoviePlayerController}. \\
\textit{MPMoviePlayerController} tiene un atributo \textit{view} del tipo \textit{UIView} que es la vista y es este atributo el que se quiere posicionar en los cuatro puntos detectados por el filtro. Un atributo del tipo \textit{UIView} tiene un atributo \textit{frame} que es del tipo \textit{CGRect}\\
\begin{verbatim}
theMovie.view.frame = CGRectMake(0, 0, 60, 60);
\end{verbatim}
En el código anterior \textit{theMovie} es del tipo \textit{MPMoviePlayerController}. De esta manera, se tiene el inconveniente de que en principio cualquier video parecería que solamente puede ser reproducido sobre rectángulos y no en cualquier polígono de cuatro puntos por ejemplo. Sin embargo algo que sí se puede hacer a las instancias de la clase \textit{UIView} es una transformación afin o incluso, de manera más genérica, una homografía. \\
\subsection{\textit{CGAffineTransform} y \textit{CATransform3D}}
La clase \textit{UIView} tiene una propiedad llamada \textit{transform} que es del tipo \textit{CGAffineTransform}. También tiene una pripiedad llamada layer\\
\\
\\
\\
EXPLICAR AMBOS MÉTODOS Y POR QUÉ SE ELIGIÓ UNO Y NO EL OTRO
\\
\\
\subsection{Resolución de Homografía}
A continuación se hace el desarrollo de la resolución del sistema de ecuaciones que se tuvo que resolver para hallar los parámetros de la homografía que transforma una imagen de referencia en la imagen que se tiene en cada momento como resultado de la captura de la cámara. Se asume entonces que se conocen los puntos de referencia y los puntos de referencia transformados (los detectados luego del filtrado de segmentos) y lo que se quiere averiguar es la matriz $h$ que logra dicha transformación. Esta homografía 2D-2D se puede expresar en forma matricial, en coordenadas homogéneas de la siguiente manera:
\[
\left( \begin{array}{ccc}
h_{11} & h_{12} & h_{13} \\ 
h_{21} & h_{22} & h_{23} \\
h_{31} & h_{32} & h_{33} 
\end{array} \right)
\left( \begin{array}{c}
x \\ 
y \\
z
\end{array} \right)
=
\left( \begin{array}{c}
i \\
j \\
k
\end{array} \right)
\]
donde la matriz $h_{3x3}$  representa la transformación homográfica, el vector $(x,y,z)^t$  representa los puntos de referencia a ser transformados y el vector $(i,j,k)^t$  respresenta los puntos detectados cuadro a cuadro como las esquinas del marcador.\\
Asumiendo un valor unitario para las coordenadas $z$ y $k$ la resolución del sistema se simplifica mucho y no se pierde generalidad. Imponiendo esto entonces, el sistema anterior se puede expresar de la siguiente forma:
\begin{equation}\label{eq_1}
xh_{11} + yh_{12} + h_{13} = i
\end{equation}
\begin{equation}\label{eq_2}
xh_{21} + yh_{22} + h_{23} = j
\end{equation}
\begin{equation}\label{eq_3}
xh_{31} + yh_{32} + h_{33} = 1
\end{equation}
Multiplicando la ecuación \eqref{eq_3} por $i$ e igualándola a la ecuación \eqref{eq_1} se obtiene lo siguiente:
\begin{equation}
xh_{11} + yh_{12} + h_{13} = ixh_{31} + iyh_{32} + ih_{33}
\end{equation}
o lo que es lo mismo:
\begin{equation}\label{eq_4}
xh_{11} + yh_{12} + h_{13} - ixh_{31} - iyh_{32} - ih_{33}=0
\end{equation}
Procediendo de manera análoga y multiplicando la ecuación \eqref{eq_3} por $j$ e igualándola a la ecuación \eqref{eq_2} se obtiene lo siguiente:
\begin{equation}
xh_{21} + yh_{22} + h_{23} = jxh_{31} + jyh_{32} + jh_{33}
\end{equation}
o lo que es lo mismo:
\begin{equation}\label{eq_4}
xh_{21} + yh_{22} + h_{23} - jxh_{31} - jyh_{32} - jh_{33}=0
\end{equation}
Las ecuaciones \eqref{eq_3} y \eqref{eq_4} se pueden expresar en forma matricial, de la siguiente manera:
\[
\left( \begin{array}{ccccccccc}
x & y & 1 & 0 & 0 & 0 & -ix & -iy & -i \\ 
0 & 0 & 0 & x & y & 1 & -jx & -jy & -j
\end{array} \right)
\left( \begin{array}{ccccccccc}
h_{11} \\ 
h_{12} \\
h_{13} \\
h_{21} \\
h_{22} \\
h_{23} \\
h_{31} \\
h_{32} \\
h_{33}
\end{array} \right)
=
\left( \begin{array}{ccccccccc}
0 \\ 
0 \\
0 \\
0 \\
0 \\
0 \\
0 \\
0 \\
0
\end{array} \right)
\]
Teniendo entonces 4 parejas de puntos referencia y puntos transformados y asumiendo $h_{33}$ de valor unitario se tiene entonces 8 ecuaciones y 8 incógnitas, lo que lo vuelve un sistema compatible determinado que se puede expresar de la siguiente manera:
\[
\left( \begin{array}{cccccccc}
x_0 & y_0 & 1 &  0  &  0  & 0 & -i_0x_0 & -i_0y_0 \\ 
0   &  0  & 0 & x_0 & y_0 & 1 & -j_0x_0 & -j_0y_0 \\

x_1 & y_1 & 1 &  0  &  0  & 0 & -i_1x_1 & -i_1y_1 \\ 
0   &  0  & 0 & x_1 & y_1 & 1 & -j_1x_1 & -j_1y_1 \\

x_2 & y_2 & 1 &  0  &  0  & 0 & -i_2x_2 & -i_2y_2 \\ 
0   &  0  & 0 & x_2 & y_2 & 1 & -j_2x_2 & -j_2y_2 \\

x_3 & y_3 & 1 &  0  &  0  & 0 & -i_3x_3 & -i_3y_3 \\ 
0   &  0  & 0 & x_3 & y_3 & 1 & -j_3x_3 & -j_3y_3  

\end{array} \right)
\left( \begin{array}{cccccccc}
h_{11} \\ 
h_{12} \\
h_{13} \\
h_{21} \\
h_{22} \\
h_{23} \\
h_{31} \\
h_{32} 
\end{array} \right)
=
\left( \begin{array}{cccccccc}
i_0 \\ 
j_0 \\
i_1 \\
j_1 \\
i_2 \\
j_2 \\
i_3 \\
j_3
\end{array} \right)
\]
Así entonces, lo que se hace para resolver la homografía es cuadro a cuadro tener detectados los puntos en los que se quiere presentar la vista del video que se corresponden con cuatro puntos detectados por el filtro y tener las correspondencias con el marcador real, se posiciona la vista en la posición de referencia y se le aplica la homografía hallada que vincula la posición referencia con los puntos detectados.
\section{Caso de Uso 03}
\subsection{Comentarios sobre el caso de uso}
\subsection{Detalles constructivos}
\section{Caso de Uso 04}
\subsection{Comentarios sobre el caso de uso}
\subsection{Detalles constructivos}
